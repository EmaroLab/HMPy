<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Creator &mdash; HMPy 1 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="HMPy 1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Creator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;@See preprocessed data</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_tkagg</span> <span class="kn">import</span> <span class="n">FigureCanvasTkAgg</span><span class="p">,</span> <span class="n">NavigationToolbar2TkAgg</span>
<span class="kn">from</span> <span class="nn">matplotlib.backend_bases</span> <span class="kn">import</span> <span class="n">key_press_handler</span>
<span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
<span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">patches</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span><span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span><span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">lfilter</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">medfilt</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">filter_design</span> <span class="k">as</span> <span class="n">ifd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">multivariate_normal</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">multivariate_normal</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">silhouette_samples</span><span class="p">,</span> <span class="n">silhouette_score</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="kn">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GMM</span>


<div class="viewcode-block" id="Creator"><a class="viewcode-back" href="../Creator.html#Creator.Creator">[docs]</a><span class="k">class</span> <span class="nc">Creator</span><span class="p">():</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GenerateModel assumes the trials provided to be the</span>
<span class="sd">    modelling dataset of a Human Motion Primitive (HMP) and returns the model</span>
<span class="sd">    of the HMP computed by executing Gaussian Mixture Modelling (GMM) and</span>
<span class="sd">    Gaussian Mixture Regression (GMR) over the modelling dataset. The</span>
<span class="sd">    model is defined by the expected curve and associated set of covariance</span>
<span class="sd">    matrices of the features extracted from the trials.</span>

<span class="sd">    Actually considered features are:</span>
<span class="sd">    - 4D gravity (time, gravity components on the 3 axes)</span>
<span class="sd">    - 4D body acceleration (time, body acc. components on the 3 axes)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lista</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#Acceleration set in X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_set_acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#Acceleration set in Y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_set_acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#Acceleration set in Z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_set_acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#list of acceleration files</span>

<div class="viewcode-block" id="Creator.ReadFiles"><a class="viewcode-back" href="../Creator.html#Creator.Creator.ReadFiles">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">names_acc</span><span class="p">,</span> <span class="n">names_gyro</span><span class="p">,</span> <span class="n">acc</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">gyro</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">dfilter</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the data from a list of files</span>

<span class="sd">            :param names_acc: list of files that contains the accelerometer data to be used as modelling dataset for a HMP</span>
<span class="sd">            :param names_gyro: list of files that contains the gyroscope data to be used as modelling dataset for a HMP</span>
<span class="sd">            :param acc: bool parameter that indicates if the accelerometer data will be used</span>
<span class="sd">            :param gyro: bool parameter that indicates if the gyroscope data will be used</span>
<span class="sd">            :param dfilter: type of filter used to reduce noise in the data</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names_acc</span> <span class="o">=</span> <span class="n">names_acc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names_gyrp</span> <span class="o">=</span> <span class="n">names_gyro</span>
        
        <span class="sd">&quot;&quot;&quot;Read the acceleration data from txt files&quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">acc</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_acc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lista</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    
                    <span class="n">noisy_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lista</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">noisy_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lista</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">noisy_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lista</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="k">if</span><span class="p">(</span><span class="n">dfilter</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">):</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">#order of the median filter</span>
                        <span class="n">x_set</span> <span class="o">=</span> <span class="n">medfilt</span><span class="p">(</span><span class="n">noisy_x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">y_set</span> <span class="o">=</span> <span class="n">medfilt</span><span class="p">(</span><span class="n">noisy_y</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">z_set</span> <span class="o">=</span> <span class="n">medfilt</span><span class="p">(</span><span class="n">noisy_z</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                        
                        <span class="bp">self</span><span class="o">.</span><span class="n">x_set_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_set</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">y_set_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_set</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">z_set_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_set</span><span class="p">)</span>
                        
                    <span class="bp">self</span><span class="o">.</span><span class="n">numSamples</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                    
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> ------- Error in the files -------------- </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="sd">&quot;&quot;&quot;Read the gyroscopre data from txt files&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Creator.CreateDatasets_Acc"><a class="viewcode-back" href="../Creator.html#Creator.Creator.CreateDatasets_Acc">[docs]</a>    <span class="k">def</span> <span class="nf">CreateDatasets_Acc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; CreateDatasets computes the gravity and body acceleration components of the trials given in the [dataset]s by calling the function GetComponents for each trial and reshapes the results into one set of gravity components and one set of body acceleration components according to the requirements of Gaussian Mixture Modelling.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#% SEPARATE THE GRAVITY AND BODY-MOTION ACCELERATION COMPONENTS</span>

        <span class="c1">#Obtain the number of files </span>
        <span class="n">numFiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_set_acc</span><span class="p">)</span>
        <span class="n">gravity_trial</span><span class="p">,</span><span class="n">body_trial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetComponents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_set_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_set_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_set_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">gravity_trial</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1">#print self.shortNumSamples</span>
        <span class="c1">#initial values of the dataset arrays</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span>
        
        <span class="n">time</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">g_x_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">g_y_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">g_z_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">b_x_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">b_y_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">b_z_s</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">):</span>
            <span class="n">gravity_trial</span><span class="p">,</span><span class="n">body_trial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetComponents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_set_acc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_set_acc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_set_acc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># CREATE THE DATASETS FOR THE GMMs</span>
            <span class="n">timec</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span><span class="n">timec</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">g_x_s</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">g_x_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">g_y_s</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">g_y_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">g_z_s</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">g_z_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">gravity_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">b_x_s</span><span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">b_x_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">b_y_s</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">b_y_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">b_z_s</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">b_z_s</span><span class="p">,</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">*</span><span class="n">body_trial</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">shortNumSamples</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span><span class="mi">1</span>

        

        <span class="n">gravity</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span><span class="n">g_x_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">gravity</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">gravity</span><span class="p">,</span> <span class="n">g_y_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">gravity</span><span class="p">,</span> <span class="n">g_z_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">body</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">time</span><span class="p">,</span><span class="n">b_x_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">body</span><span class="p">,</span><span class="n">b_y_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">body</span><span class="p">,</span><span class="n">b_z_s</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span></div>

    <span class="c1">#2.1</span>
<div class="viewcode-block" id="Creator.GetComponents"><a class="viewcode-back" href="../Creator.html#Creator.Creator.GetComponents">[docs]</a>    <span class="k">def</span> <span class="nf">GetComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_axis</span><span class="p">,</span> <span class="n">y_axis</span><span class="p">,</span> <span class="n">z_axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; GetComponents discriminates between gravity and body acceleration by</span>
<span class="sd">            applying an infinite impulse response (IIR) filter to the raw</span>
<span class="sd">            acceleration data (one trial) given in input.</span>

<span class="sd">            :param x_axis: acceleration data in the axis x</span>
<span class="sd">            :param y_axis: acceleration data in the axis y</span>
<span class="sd">            :param z_axis: acceleration data in the axis z</span>
<span class="sd">            :return gravity: gravity component of the acceleration data</span>
<span class="sd">            :return body: body component of the acceleration data</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
        
        <span class="c1">#APPLY IIR FILTER TO GET THE GRAVITY COMPONENTS</span>
        <span class="c1">#IIR filter parameters (all frequencies are in Hz)</span>
        <span class="n">Fs</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>            <span class="c1"># sampling frequency</span>
        <span class="n">Fpass</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">;</span>       <span class="c1"># passband frequency</span>
        <span class="n">Fstop</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1"># stopband frequency</span>
        <span class="n">Apass</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">;</span>      <span class="c1"># passband ripple (dB)</span>
        <span class="n">Astop</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>        <span class="c1"># stopband attenuation (dB)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="s1">&#39;pass&#39;</span><span class="p">;</span>     <span class="c1"># band to match exactly</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>          <span class="c1"># delay (# samples) introduced by filtering</span>
        <span class="c1">#Create the IIR filter</span>

        

        <span class="c1"># iirdesign agruements</span>
        <span class="n">Wip</span> <span class="o">=</span> <span class="p">(</span><span class="n">Fpass</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Wis</span> <span class="o">=</span> <span class="p">(</span><span class="n">Fstop</span><span class="o">+</span><span class="mf">1e6</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Rp</span> <span class="o">=</span> <span class="n">Apass</span>             <span class="c1"># passband ripple</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">Astop</span>            <span class="c1"># stopband attenuation</span>

        <span class="c1"># The iirdesign takes passband, stopband, passband ripple, </span>
        <span class="c1"># and stop attenuation. </span>
        <span class="n">bb</span><span class="p">,</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">ifd</span><span class="o">.</span><span class="n">iirdesign</span><span class="p">(</span><span class="n">Wip</span><span class="p">,</span> <span class="n">Wis</span><span class="p">,</span> <span class="n">Rp</span><span class="p">,</span> <span class="n">As</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;cheby1&#39;</span><span class="p">)</span>
        
        <span class="n">g1</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span><span class="n">ab</span><span class="p">,</span><span class="n">x_axis</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span><span class="n">ab</span><span class="p">,</span><span class="n">y_axis</span><span class="p">)</span>
        <span class="n">g3</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span><span class="n">ab</span><span class="p">,</span><span class="n">z_axis</span><span class="p">)</span>

        <span class="c1">#COMPUTE THE BODY-ACCELERATION COMPONENTS BY SUBTRACTION  (PREGUNTA)</span>
        <span class="n">gravity</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">numSamples</span> <span class="o">-</span><span class="n">delay</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">numSamples</span> <span class="o">-</span><span class="n">delay</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSamples</span><span class="o">-</span><span class="n">delay</span><span class="p">):</span>
            <span class="c1">#shift &amp; reshape gravity to reduce the delaying effect of filtering</span>
            <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">delay</span><span class="p">];</span>
            <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">g2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">delay</span><span class="p">];</span>
            <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">g3</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">delay</span><span class="p">];</span>
            
            <span class="n">body</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">body</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">body</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">gravity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1">#COMPUTE THE BODY-ACCELERATION COMPONENTS BY SUBTRACTION</span>
        <span class="k">return</span> <span class="n">gravity</span><span class="p">,</span> <span class="n">body</span></div>


    <span class="c1">#3</span>

<div class="viewcode-block" id="Creator.ObtainNumberOfCluster"><a class="viewcode-back" href="../Creator.html#Creator.Creator.ObtainNumberOfCluster">[docs]</a>    <span class="k">def</span> <span class="nf">ObtainNumberOfCluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">acc</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">gyro</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;KMeans&quot;</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the expected curve for each dataset</span>

<span class="sd">            :param acc: bool parameter that indicates if the accelerometer data will be used</span>
<span class="sd">            :param gyro: bool parameter that indicates if the gyroscope data will be used</span>
<span class="sd">            :param algorithm: algorithm used to obtain the number of clusters</span>
<span class="sd">            :param save: bool parameter that indicates if the plots are saved</span>
<span class="sd">            :param path: path where the plots will be saved</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Determine the number of Gaussians to be used in the GMM</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acc</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K_gravity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TuneK</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gravity</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="s1">&#39;gravity&#39;</span><span class="p">,</span><span class="n">save</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
            <span class="k">print</span> <span class="s2">&quot;K gravity = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_gravity</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K_body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TuneK</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="s1">&#39;body&#39;</span><span class="p">,</span><span class="n">save</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
            <span class="k">print</span> <span class="s2">&quot;K body = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_body</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="Creator.TuneK"><a class="viewcode-back" href="../Creator.html#Creator.Creator.TuneK">[docs]</a>    <span class="k">def</span> <span class="nf">TuneK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">set_</span><span class="p">,</span> <span class="n">maxK</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; TuneK determines the optimal number of clusters to be used to cluster</span>
<span class="sd">            the given [set] with K-means algorithm. It cycles from K = 2 to [maxK].</span>
<span class="sd">            The optimization criterion adopted is a variant of the elbow method: at</span>
<span class="sd">            each iteration TuneK computes the silhouette values of the clusters</span>
<span class="sd">            determined by the K-means algorithm and compares them with the values</span>
<span class="sd">            obtained at the previous iteration. When the quality of the</span>
<span class="sd">            clustering falls below a fixed threshold, TuneK stops.</span>

<span class="sd">            :param set_: either the gravity or the body acc. dataset retrived from</span>
<span class="sd">                CreateDatasets</span>
<span class="sd">            :param maxK: maximum number of clusters to be used to cluster the given</span>
<span class="sd">                dataset.</span>
<span class="sd">            :param name: component name (gravity or body)</span>
<span class="sd">            :param save: bool parameter that indicates if the plots are saved</span>
<span class="sd">            :param path: path where the plots will be saved</span>
<span class="sd">            :return Koptimal: optimal number of clusters to be used to cluster the data</span>
<span class="sd">                of the given dataset&quot;&quot;&quot;</span>

        <span class="c1"># DETERMINE THE OPTIMAL NUMBER OF CLUSTERS (K) FOR THE GIVEN DATASET</span>
        <span class="c1"># tuning parameters</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.69</span>  <span class="c1"># threshold on the FITNESS of the current clustering</span>
        <span class="n">minK</span> <span class="o">=</span> <span class="mi">2</span>         <span class="c1"># initial number of clusters to be used</span>
        <span class="c1">#first step is outside of the loop to have meaningful initial values</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">set_</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="c1">#[:,1:]</span>
        <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">print</span>   <span class="s2">&quot;samples= &quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="s2">&quot;features&quot;</span><span class="p">,</span> <span class="n">n_features</span>
        <span class="c1">#n_digits = len(unique(digits.target))</span>
        <span class="c1">#labels = digits.target</span>

        <span class="k">print</span><span class="p">(</span><span class="mi">79</span> <span class="o">*</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bench_k_means</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">save</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Creator.bench_k_means"><a class="viewcode-back" href="../Creator.html#Creator.Creator.bench_k_means">[docs]</a>    <span class="k">def</span> <span class="nf">bench_k_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Silhouette analysis</span>

<span class="sd">            :param data: dataset trasposed</span>
<span class="sd">            :param name: component name (gravity or body)</span>
<span class="sd">            :param save: bool parameter that indicates if the plots are saved</span>
<span class="sd">            :param path: path where the plots will be saved</span>
<span class="sd">            :return Koptimal: optimal number of clusters to be used to cluster the data of the given dataset&quot;&quot;&quot;</span>
    
        <span class="c1">#In this example the silhouette analysis is used to choose an optimal value for n_clusters.</span>
        <span class="c1">#Bad pick for the given data due to the presence of clusters with</span>
        <span class="c1">#below average silhouette scores and also due to wide fluctuations in the size of the silhouette plots.</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.69</span><span class="p">;</span>

        <span class="c1">#t0 = time()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">cmin</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">cmax</span> <span class="o">=</span> <span class="mi">50</span>

        
        <span class="k">for</span> <span class="n">n_clusters</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmin</span><span class="p">,</span><span class="n">cmax</span><span class="p">):</span>
            <span class="c1"># Create a subplot with 1 row and 2 columns</span>

            <span class="k">if</span><span class="p">(</span><span class="n">plot</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>

                <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
                
                
                <span class="c1"># The 1st subplot is the silhouette plot</span>
                <span class="c1"># The silhouette coefficient can range from -1, 1 but in this example all</span>
                <span class="c1"># lie within [-0.1, 1]</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># The (n_clusters+1)*10 is for inserting blank space between silhouette</span>
                <span class="c1"># plots of individual clusters, to demarcate them clearly.</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">])</span>

            <span class="c1"># Initialize the clusterer with n_clusters value and a random generator</span>
            <span class="c1"># seed of 10 for reproducibility.</span>
            <span class="n">clusterer</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="c1">#cluster_labels = clusterer.fit(X)</span>

            <span class="c1"># The silhouette_score gives the average value for all the samples.</span>
            <span class="c1"># This gives a perspective into the density and separation of the formed</span>
            <span class="c1"># clusters</span>
            <span class="n">silhouette_avg</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;For n_clusters =&quot;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span>
                  <span class="s2">&quot;The average silhouette_score is :&quot;</span><span class="p">,</span> <span class="n">silhouette_avg</span><span class="p">)</span>

            <span class="c1"># Compute the silhouette scores for each sample</span>
            <span class="n">sample_silhouette_values</span> <span class="o">=</span> <span class="n">silhouette_samples</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">)</span>
            <span class="c1">#print sample_silhouette_values</span>

            <span class="n">Koptimal</span> <span class="o">=</span> <span class="n">n_clusters</span>
            <span class="c1">#if (Koptimal == maxK):</span>
                <span class="c1">#print(&#39;MATLAB:noConvergence&#39;,&#39;Failed to converge to the optimal K: increase maxK.&#39;)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">silhouette_avg</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">Koptimal</span><span class="p">)</span>


            <span class="n">y_lower</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
                <span class="c1"># Aggregate the silhouette scores for samples belonging to</span>
                <span class="c1"># cluster i, and sort them</span>
                <span class="n">ith_cluster_silhouette_values</span> <span class="o">=</span> \
                    <span class="n">sample_silhouette_values</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>

                <span class="n">ith_cluster_silhouette_values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="n">size_cluster_i</span> <span class="o">=</span> <span class="n">ith_cluster_silhouette_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y_upper</span> <span class="o">=</span> <span class="n">y_lower</span> <span class="o">+</span> <span class="n">size_cluster_i</span>

                <span class="n">color</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">spectral</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_clusters</span><span class="p">)</span>

                <span class="k">if</span><span class="p">(</span><span class="n">plot</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">fill_betweenx</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">y_lower</span><span class="p">,</span> <span class="n">y_upper</span><span class="p">),</span>
                                      <span class="mi">0</span><span class="p">,</span> <span class="n">ith_cluster_silhouette_values</span><span class="p">,</span>
                                      <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

                    <span class="c1"># Label the silhouette plots with their cluster numbers at the middle</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">y_lower</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">size_cluster_i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

                    <span class="c1"># Compute the new y_lower for next plot</span>
                    <span class="n">y_lower</span> <span class="o">=</span> <span class="n">y_upper</span> <span class="o">+</span> <span class="mi">10</span>  <span class="c1"># 10 for the 0 samples</span>

            <span class="k">if</span><span class="p">(</span><span class="n">plot</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;The silhouette plot for the various clusters.&quot;</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;The silhouette coefficient values&quot;</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Cluster label&quot;</span><span class="p">)</span>

                <span class="c1"># The vertical line for average silhoutte score of all the values</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">silhouette_avg</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

                <span class="n">ax1</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>  <span class="c1"># Clear the yaxis labels / ticks</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># 2nd Plot showing the actual clusters formed</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">spectral</span><span class="p">(</span><span class="n">cluster_labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_clusters</span><span class="p">)</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                            <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>

                <span class="c1"># Labeling the clusters</span>
                <span class="n">centers</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">cluster_centers_</span>
                <span class="c1"># Draw white circles at cluster centers</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
                    <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">%d</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

                <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;The visualization of the clustered data.&quot;</span><span class="p">)</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Feature space for the 1st feature&quot;</span><span class="p">)</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Feature space for the 2nd feature&quot;</span><span class="p">)</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">((</span><span class="s2">&quot;Silhouette analysis for KMeans clustering on sample data &quot;</span>
                              <span class="s2">&quot;with n_clusters = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n_clusters</span><span class="p">),</span>
                             <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_c_&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Koptimal</span></div>

<div class="viewcode-block" id="Creator.runGMM"><a class="viewcode-back" href="../Creator.html#Creator.Creator.runGMM">[docs]</a>    <span class="k">def</span> <span class="nf">runGMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dataset</span><span class="p">,</span><span class="n">K</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute GMM in a data set given a K number of clusters</span>
<span class="sd">            :param dataset: either the gravity or the body acc. dataset retrived from CreateDatasets</span>
<span class="sd">            :param K: number of clusters</span>
<span class="sd">            :return priors: apriori probavbility</span>
<span class="sd">            :return mu: mean</span>
<span class="sd">            :return sigma: covariance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gmm</span> <span class="o">=</span> <span class="n">GMM</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">K</span><span class="p">,</span><span class="n">covariance_type</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="n">gmm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="n">priors</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">weights_</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">covars_</span>

        <span class="k">return</span> <span class="n">priors</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span></div>


<div class="viewcode-block" id="Creator.GetExpected"><a class="viewcode-back" href="../Creator.html#Creator.Creator.GetExpected">[docs]</a>    <span class="k">def</span> <span class="nf">GetExpected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">set_</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">numGMRPoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;GetExpected performs Gaussian Mixture Modeling (GMM) and Gaussian Mixture</span>
<span class="sd">        Regression (GMR) over the given dataset. It returns the expected curve</span>
<span class="sd">        (expected mean for each point, computed over the values given in the</span>
<span class="sd">        [set]) and associated set of covariance matrices defining the &quot;model&quot;</span>
<span class="sd">        of the given dataset. </span>
<span class="sd">    </span>
<span class="sd">        :param set: either the gravity or the body acc. dataset retrived from CreateDatasets</span>
<span class="sd">        :param K: optimal number of clusters to be used to cluster the data of the given dataset retrieved from TuneK</span>
<span class="sd">        :param numGMRPoints: number of data points composing the expected curves to be computed by GMR</span>

<span class="sd">        :return expData: expected curve obtained by modelling the given dataset with the GMM+GMR procedure</span>
<span class="sd">        :return expSigma: associated covariance matrices obtained by modelling the given dataset with the GMM+GMR procedure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># PARAMETERS OF THE GMM+GMR PROCEDURE</span>
        <span class="n">numVar</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>            <span class="c1"># number of variables in the system (time &amp; 3 accelerations)</span>
        <span class="n">m</span><span class="p">,</span><span class="n">numData</span> <span class="o">=</span> <span class="n">set_</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span><span class="c1"># number of points in the dataset</span>
        
        <span class="n">priors</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runGMM</span><span class="p">(</span><span class="n">set_</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>

        <span class="c1">#APPLY GAUSSIAN MIXTURE REGRESSION TO FIND THE EXPECTED CURVE</span>
        <span class="c1">#define the points to be used for the regression</span>
        <span class="c1">#(assumption: CONSTANT SPACING)</span>
        
        <span class="n">expData1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numGMRPoints</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">numGMRPoints</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">expMeans</span><span class="p">,</span> <span class="n">expSigma</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">RetrieveModel</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">priors</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">expData1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numVar</span><span class="p">),</span><span class="n">numVar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expMeans</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">expSigma</span></div>
        
           

<div class="viewcode-block" id="Creator.RetrieveModel"><a class="viewcode-back" href="../Creator.html#Creator.Creator.RetrieveModel">[docs]</a>    <span class="k">def</span> <span class="nf">RetrieveModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">priors</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">points</span><span class="p">,</span><span class="n">in_</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">numVar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Performs Gaussian Mixture Regression (GMR) over the GM model defined by its parameters. By providing temporal values as inputs, it returns a smooth generalized version of the data encoded in the GMM and the associated constraints expressed by the covariance matrices.</span>

<span class="sd">            :param K: number of clusters</span>
<span class="sd">            :param priors: apriori probavbility</span>
<span class="sd">            :param mu: mean</span>
<span class="sd">            :param sigma: covariance</span>
<span class="sd">            :param points: input data (starting points to be used for GMR)</span>
<span class="sd">            :param in: input dimension</span>
<span class="sd">            :param out: output dimension</span>
<span class="sd">            :param numVar: axis number, ex: if we use x,y,z then this parameters must be = 3</span>

<span class="sd">            :return expMeans: set of expected means for the given GM model</span>
<span class="sd">            :return expSigma: covariance matrices of the expected points in expMeans</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numData</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">pdf_point</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">numData</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">numData</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
        <span class="n">exp_point_k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">numVar</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">numData</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
        <span class="n">exp_sigma_k</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="c1"># compute the probability of each point to belong to the actual GM</span>
            <span class="c1"># model (probability density function of the point) --&gt; p(point)</span>
            <span class="n">pdf_point_temp</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">mu</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">in_</span><span class="p">],</span><span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">in_</span><span class="p">,</span><span class="n">in_</span><span class="p">])</span>
            
            <span class="c1">#compute p(Gaussians) * p(point|Gaussians)</span>
            <span class="n">pdf_point</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span> <span class="n">pdf_point_temp</span>
            
        <span class="c1">#estimate the parameters beta</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">beta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdf_point</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">pdf_point</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="n">numData</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">out</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">+</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">numVar</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">in_</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">in_</span><span class="p">,</span><span class="n">in_</span><span class="p">])))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">points</span><span class="o">-</span><span class="n">tile</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">in_</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="n">numData</span><span class="p">]))</span>
            <span class="n">exp_point_k</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="n">beta_tmp</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">beta</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">numData</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
        <span class="c1">#print tile(beta_tmp,[size(out),1,1]).shape</span>
        <span class="n">exp_point_k2</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">beta_tmp</span><span class="p">,[</span><span class="n">size</span><span class="p">(</span><span class="n">out</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">exp_point_k</span><span class="p">;</span>
        <span class="c1">#compute the set of expected means</span>
        <span class="n">expMeans</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp_point_k2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">K</span><span class="p">):</span>                   
            <span class="n">temp</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">numVar</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">numVar</span><span class="p">]</span> <span class="o">-</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">numVar</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">in_</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">in_</span><span class="p">,</span><span class="n">in_</span><span class="p">])))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">in_</span><span class="p">,</span><span class="n">out</span><span class="p">]</span>
            <span class="n">exp_sigma_k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

            
        <span class="n">expSigma_temp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">numData</span><span class="p">):</span>
            <span class="n">expSigma_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">zeros</span><span class="p">((</span><span class="n">numVar</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">numVar</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">K</span><span class="p">):</span>
                        <span class="n">expSigma_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">expSigma_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">exp_sigma_k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">expSigma</span> <span class="o">=</span> <span class="n">expSigma_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numData</span><span class="p">):</span>
            <span class="n">expSigma</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">expSigma</span><span class="p">,</span> <span class="n">expSigma_temp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">expMeans</span><span class="p">,</span> <span class="n">expSigma</span></div></div>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Luis Enrique Coronado Zuñiga.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>